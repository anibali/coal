grammar CoalTreetop
  rule root
    ws? statements ws? {
      def tree
        statements.tree
      end
    }
  end

  rule statements
    statement ((ws? comment)+ / statement_separator) statements {
      def tree
        [statement.tree].compact.concat(statements.tree)
      end
    }
    /
    statement (ws comment)* {
      def tree
        [statement.tree].compact
      end
    }
  end
  
  rule statement_separator
    [ \t\r]* "\n" ws?
    /
    ws? ";" ws?
  end
  
  rule statement
    return
    /
    break
    /
    if_unless
    /
    while_until
    /
    declaration
    /
    expression
    /
    '' {
      def tree
        nil
      end
    }
  end
  
  rule if_unless
    type:('if'/'unless') gap? '(' gap? expression gap? ')' ws? then_block:block ws? 'else' ws? else_block:block {
      def tree
        [type.text_value.to_sym, expression.tree, then_block.tree, else_block.tree]
      end
    }
    /
    type:('if'/'unless') gap? '(' gap? expression gap? ')' ws? block {
      def tree
        [type.text_value.to_sym, expression.tree, block.tree]
      end
    }
  end
  
  rule while_until
    type:('while'/'until') gap? '(' gap? expression gap? ')' ws? block {
      def tree
        [type.text_value.to_sym, expression.tree, block.tree]
      end
    }
  end
  
  rule block
    '{' ws? statements ws? '}' {
      def tree
        statements.tree
      end
    }
    /
    statement {
      def tree
        [super].compact
      end
    }
  end
  
  rule expression
    assignment
  end
  
  rule declaration
    type gap identifier gap? '=' gap? expression {
      def tree
        [:decl, type.tree, identifier.tree, expression.tree]
      end
    }
    /
    type gap identifier {
      def tree
        [:decl, type.tree, identifier.tree]
      end
    }
  end
  
  rule pre_assign_op
    '**'/'+'/'-'/'*'/'/'/'%'/'&'/'^'/'|'/'<<'/'>>'
  end
  
  rule assignment
    identifier gap? '=' gap? assignment {
      def tree
        [:sto, identifier.tree, assignment.tree]
      end
    }
    /
    identifier gap? pre_assign_op '=' gap? assignment {
      def tree
        var = identifier.tree
        [:sto, var, [BINARY_SYMS[pre_assign_op.text_value], var, assignment.tree]]
      end
    }
    /
    or
  end
  
  rule or
    (and gap? '&&' gap?)+ or <BinaryOpLTR>
    /
    and
  end
  
  rule and
    (bitwise_or gap? '&&' gap?)+ and <BinaryOpLTR>
    /
    bitwise_or
  end
  
  rule bitwise_or
    (bitwise_xor gap? '|' gap?)+ bitwise_or <BinaryOpLTR>
    /
    bitwise_xor
  end
  
  rule bitwise_xor
    (bitwise_and gap? '^' gap?)+ bitwise_xor <BinaryOpLTR>
    /
    bitwise_and
  end
  
  rule bitwise_and
    (equality gap? '&' gap?)+ bitwise_and <BinaryOpLTR>
    /
    equality
  end
  
  rule equality
    comparison gap? ('=='/'!=') gap? equality <BinaryOpRTL>
    /
    comparison
  end
  
  rule comparison
    shift gap? ('<='/'<'/'>='/'>') gap? comparison <BinaryOpRTL>
    /
    shift
  end
  
  rule shift
    (sum gap? ('<<'/'>>') gap?)+ shift <BinaryOpLTR>
    /
    sum
  end
  
  rule sum
    (term gap? [+-] gap?)+ sum <BinaryOpLTR>
    /
    term
  end

  rule term
    (power gap? [*/%] gap?)+ term <BinaryOpLTR>
    /
    power
  end
  
  rule power
    unary gap? '**' gap? power <BinaryOpRTL>
    /
    unary
  end
  
  rule unary
    '*' unary ':' type {
      def tree
        [UNARY_SYMS['*'], unary.tree, type.tree]
      end
    }
    /
    op:[-~@*] unary {
      def tree
        [UNARY_SYMS[op.text_value], unary.tree]
      end
    }
    /
    primary
  end
  
  rule primary
    '(' gap? expression gap? ')' {
      def tree
        expression.tree
      end
    }
    /
    arg
    /
    integer
    /
    boolean
    /
    identifier
  end
  
  rule boolean
    'true' {
      def tree ; true ; end
    }
    /
    'false' {
      def tree ; false ; end
    }
  end
  
  rule integer
    # Binary
    '0b' [01]+ {
      def tree
        text_value.to_i(2)
      end
    }
    /
    # Hex
    '0x' [0-9a-fA-F]+ {
      def tree
        text_value.to_i(16)
      end
    }
    /
    # Arbitrary radix (must be between 2 and 36 inclusive)
    radix:([0-9]+) 'r' num:([0-9a-zA-Z]+) {
      def tree
        num.text_value.to_i(radix.text_value.to_i)
      end
    }
    /
    # Decimal
    [0-9]+ {
      def tree
        text_value.to_i
      end
    }
  end
  
  rule identifier
    [a-z_] [a-zA-Z_0-9]* {
      def tree
        text_value
      end
    }
  end
  
  rule type
    ptrs:('@'*) base:([a-zA-Z] [a-zA-Z0-9]*) {
      def tree
        if ptrs.nil? || ptrs.text_value.empty?
          base.text_value
        else
          typ = []
          ptrs.text_value.length.times { typ << 'pointer' }
          typ << base.text_value
        end
      end
    }
  end
  
  rule arg
    'arg(' gap? integer gap? ')' {
      def tree
        [:arg, integer.tree]
      end
    }
  end
  
  rule break
    'break' ![a-zA-Z_0-9] {
      def tree
        [:break]
      end
    }
  end
  
  rule return
    'return(' gap? expression gap? ')' {
      def tree
        [:ret, expression.tree]
      end
    }
  end
  
  rule eoc
    "\n" / eof
  end

  rule comment
    '#' (!eoc .)* eoc
  end
  
  rule eof
    !.
  end
  
  # Horizontal whitespace
  rule gap
    [ \t]+
  end
  
  # Any whitespace
  rule ws
    [ \t\n\r]+
  end
end

