grammar CoalTreetop
  rule root
    ws? statements ws? {
      def tree
        statements.tree
      end
    }
  end

  rule statements
    statement ((ws? comment)+ / statement_separator) statements {
      def tree
        [statement.tree].compact.concat(statements.tree)
      end
    }
    /
    statement (ws comment)* {
      def tree
        [statement.tree].compact
      end
    }
  end
  
  rule statement_separator
    [ \t\r]* "\n" ws?
    /
    ws? ";" ws?
  end
  
  rule statement
    return
    /
    break
    /
    if_unless
    /
    while_until
    /
    declaration
    /
    expression
    /
    '' {
      def tree
        nil
      end
    }
  end
  
  rule if_unless
    type:('if'/'unless') gap? '(' gap? expression gap? ')' ws? then_block:block ws? 'else' ws? else_block:block {
      def tree
        [type.text_value.to_sym, expression.tree, then_block.tree, else_block.tree]
      end
    }
    /
    type:('if'/'unless') gap? '(' gap? expression gap? ')' ws? block {
      def tree
        [type.text_value.to_sym, expression.tree, block.tree]
      end
    }
  end
  
  rule while_until
    type:('while'/'until') gap? '(' gap? expression gap? ')' ws? block {
      def tree
        [type.text_value.to_sym, expression.tree, block.tree]
      end
    }
  end
  
  rule block
    '{' ws? statements ws? '}' {
      def tree
        statements.tree
      end
    }
    /
    statement {
      def tree
        [super].compact
      end
    }
  end
  
  rule expression
    assignment
  end
  
  rule declaration
    type gap identifier gap? '=' gap? expression {
      def tree
        [:decl, type.tree, identifier.tree, expression.tree]
      end
    }
    /
    type gap identifier {
      def tree
        [:decl, type.tree, identifier.tree]
      end
    }
  end
  
  rule pre_assign_op
    '**'/'+'/'-'/'*'/'/'/'%'/'&'/'^'/'|'/'<<'/'>>'
  end
  
  rule assignment
    identifier gap? '=' gap? assignment {
      def tree
        [:sto, identifier.tree, assignment.tree]
      end
    }
    /
    primary gap? '.' gap? identifier gap? '=' gap? assignment {
      #TODO: enable chains like a.b.c = d
      def tree
        [:set, primary.tree, identifier.tree, assignment.tree]
      end
    }
    /
    identifier gap? pre_assign_op '=' gap? assignment {
      def tree
        var = identifier.tree
        [:sto, var, [BINARY_SYMS[pre_assign_op.text_value], var, assignment.tree]]
      end
    }
    /
    xor
  end
  
  rule xor
    (or gap? '^^' gap?)+ xor <BinaryOpLTR>
    /
    or
  end
  
  rule or
    (and gap? '||' gap?)+ or <BinaryOpLTR>
    /
    and
  end
  
  rule and
    (bitwise_or gap? '&&' gap?)+ and <BinaryOpLTR>
    /
    bitwise_or
  end
  
  rule bitwise_or
    (bitwise_xor gap? '|' gap?)+ bitwise_or <BinaryOpLTR>
    /
    bitwise_xor
  end
  
  rule bitwise_xor
    (bitwise_and gap? '^' gap?)+ bitwise_xor <BinaryOpLTR>
    /
    bitwise_and
  end
  
  rule bitwise_and
    (equality gap? '&' gap?)+ bitwise_and <BinaryOpLTR>
    /
    equality
  end
  
  rule equality
    comparison gap? ('=='/'!=') gap? equality <BinaryOpRTL>
    /
    comparison
  end
  
  rule comparison
    shift gap? ('<='/'<'/'>='/'>') gap? comparison <BinaryOpRTL>
    /
    shift
  end
  
  rule shift
    (sum gap? ('<<'/'>>') gap?)+ shift <BinaryOpLTR>
    /
    sum
  end
  
  rule sum
    (term gap? [+-] gap?)+ sum <BinaryOpLTR>
    /
    term
  end

  rule term
    (power gap? [*/%] gap?)+ term <BinaryOpLTR>
    /
    power
  end
  
  rule power
    unary gap? '**' gap? power <BinaryOpRTL>
    /
    unary
  end
  
  rule unary
    '*' unary ':' type {
      def tree
        [UNARY_SYMS['*'], unary.tree, type.tree]
      end
    }
    /
    op:[-~@*!] unary {
      def tree
        [UNARY_SYMS[op.text_value], unary.tree]
      end
    }
    /
    '(' gap? type gap? ')' gap? unary {
      def tree
        [:cast, unary.tree, type.tree]
      end
    }
    /
    member
  end
  
  rule member
    (primary gap? '.' gap?)+ identifier <BinaryOpLTR>
    /
    primary
  end
  
  rule primary
    '(' gap? expression gap? ')' {
      def tree
        expression.tree
      end
    }
    /
    arg
    /
    function_call
    /
    integer
    /
    boolean
    /
    stringz
    /
    identifier
  end
  
  rule function
    (identifier gap? '.' gap?)* identifier <BinaryOpLTR> {
      def tree
        elements[0].elements.map {|e| e.elements[0].text_value} << identifier.text_value
      end
    }
  end
  
  rule function_call
    function '(' gap? arguments gap? ')' {
      def tree
        [:call, function.tree, arguments.tree]
      end
    }
  end
  
  rule arguments
    expression gap? ',' gap? arguments {
      def tree
        [expression.tree].concat(arguments.tree)
      end
    }
    /
    expression {
      def tree
        [super]
      end
    }
    /
    (gap / '') {
      def tree
        []
      end
    }
  end
  
  rule boolean
    'true' {
      def tree ; true ; end
    }
    /
    'false' {
      def tree ; false ; end
    }
  end
  
  rule integer
    # Binary
    '0b' [01]+ {
      def tree
        text_value.to_i(2)
      end
    }
    /
    # Hex
    '0x' [0-9a-fA-F]+ {
      def tree
        text_value.to_i(16)
      end
    }
    /
    # Arbitrary radix (must be between 2 and 36 inclusive)
    radix:([0-9]+) 'r' num:([0-9a-zA-Z]+) {
      def tree
        num.text_value.to_i(radix.text_value.to_i)
      end
    }
    /
    # Decimal
    [0-9]+ {
      def tree
        text_value.to_i
      end
    }
  end
  
  rule stringz
    "'" ([ -&(-\[\]-~] / "\\" .)* "'" {
      def tree
        str = text_value[1...-1].gsub(/\\./) do |match|
          char = match[-1..-1]
          if ["'", "\\"].include? char
            char
          elsif %w[n t r].include? char
            eval("\"\\#{char}\"")
          else
            raise "Invalid stringz escape character: #{match}"
          end
        end
        [:strz, str]
      end
    }
  end
  
  rule identifier
    [a-zA-Z_] [a-zA-Z_0-9]* {
      def tree
        text_value
      end
    }
  end
  
  rule identifier_cap
    [A-Z] [a-zA-Z0-9]* {
      def tree
        text_value
      end
    }
  end
  
  rule type
    (identifier_cap gap? '.' gap?)* identifier_cap {
      def tree
        [:class] + elements[0].elements.map {|e| e.elements[0].text_value} << identifier_cap.text_value
      end
    }
    /
    ptrs:('@'*) base:([a-zA-Z] [a-zA-Z0-9]*) {
      def tree
        if ptrs.nil? || ptrs.text_value.empty?
          base.text_value
        else
          typ = []
          ptrs.text_value.length.times { typ << 'pointer' }
          typ << base.text_value
        end
      end
    }
  end
  
  rule arg
    'arg(' gap? integer gap? ')' {
      def tree
        [:arg, integer.tree]
      end
    }
  end
  
  rule break
    'break' ![a-zA-Z_0-9] {
      def tree
        [:break]
      end
    }
  end
  
  rule return
    'return(' gap? expression gap? ')' {
      def tree
        [:ret, expression.tree]
      end
    }
  end
  
  rule eoc
    "\n" / eof
  end

  rule comment
    '#' (!eoc .)*
  end
  
  rule eof
    !.
  end
  
  # Horizontal whitespace
  rule gap
    [ \t]+
  end
  
  # Any whitespace
  rule ws
    [ \t\n\r]+
  end
end

