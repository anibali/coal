grammar CoalTreetop
  rule body
    ws? statement_list ws? {
      def translate(t)
        statement_list.translate(t)
      end
    }
  end  
  
  rule statement_list
    statement statement_separator statement_list {
      def translate(t)
        statement.translate(t)
        statement_list.translate(t)
      end
    }
    /
    statement
  end
  
  rule statement_separator
    ws? ';' ws? statement_separator?
    /
    gap? [\r\n] ws?
  end
  
  rule statement
    declaration_and_assignment
    /
    declaration
    /
    while_loop / until_loop
    /
    if_statement / unless_statement
    /
    block
    /
    break
    /
    expression
  end
  
  rule declaration_and_assignment
    declaration gap? '=' gap? expression {
      def translate(t)
        t.assign(declaration.translate(t), expression.translate(t))
      end
    }
  end
  
  rule declaration
    type gap variable {
      def translate(t)
        var = variable.text_value
        t.declare(type.translate(t), var)
        #var
      end
    }
  end
  
  rule block
    '{' ws? statement_list ws? '}' {
      def translate(t)
        statement_list.translate(t)
      end
    }
    /
    '{' ws? '}' {
      def translate(t)
        ""
      end
    }
  end
  
  rule break
    'break' {
      def translate(t)
        t.break
      end
    }
  end
  
  rule while_loop
    'while' gap? '(' gap? expression gap? ')' ws? statement {
      def translate(t)
        t.while(expression) do
          statement.translate(t)
        end
      end
    }
  end
  
  rule until_loop
    'until' gap? '(' gap? expression gap? ')' ws? statement {
      def translate(t)
        t.until(expression) do
          statement.translate(t)
        end
      end
    }
  end
  
  rule if_statement
    'if' gap? '(' gap? expression gap? ')' ws? statement ws? else_statement {
      def translate(t)
        t.if(expression, else_statement) do
          statement.translate(t)
        end
      end
    }
    /
    'if' gap? '(' gap? expression gap? ')' ws? statement {
      def translate(t)
        t.if(expression) do
          statement.translate(t)
        end
      end
    }
  end
  
  rule else_statement
    'else' ws? statement {
      def translate(t)
        statement.translate(t)
      end
    }
  end
  
  rule unless_statement
    'unless' gap? '(' gap? expression gap? ')' ws? statement ws? else_statement {
      def translate(t)
        t.unless(expression, else_statement) do
          statement.translate(t)
        end
      end
    }
    /
    'unless' gap? '(' gap? expression gap? ')' ws? statement {
      def translate(t)
        t.unless(expression) do
          statement.translate(t)
        end
      end
    }
  end
  
  rule function_call
    function_name '(' gap? argument_list gap? ')' {
      def translate(t)
        args = argument_list.translate(t)
        t.send function_name.translate(t), *args
      end
    }
  end
  
  # Rule for a list of comma-separated arguments. Whitespace before and after
  # the list should be trimmed beforehand.
  rule argument_list
    argument gap? ',' gap? argument_list {
      def translate(t)
        [argument.translate(t)] + argument_list.translate(t)
      end
    }
    /
    argument {
      def translate(t)
        [super]
      end
    }
    /
    '' {
      def translate(t)
        []
      end
    }
  end
  
  rule argument
    expression
  end

  rule expression
    assignment
  end
  
  rule assignment_op
    '=' / '+=' / '-=' / '*=' / '/=' / '%=' / '&=' / '^=' / '|=' / '<<=' / '>>='
  end
  
  rule assignment
    variable gap? assignment_op gap? assignment {
      def translate(t)
        var = variable.translate(t)
        val = case assignment_op.text_value
        when '='
          assignment.translate(t)
        when '+='
          t.add(var, assignment.translate(t))
        when '-='
          t.subtract(var, assignment.translate(t))
        when '*='
          t.multiply(var, assignment.translate(t))
        when '/='
          t.divide(var, assignment.translate(t))
        when '%='
          t.modulus(var, assignment.translate(t))
        when '&='
          t.bitwise_and(var, assignment.translate(t))
        when '^='
          t.bitwise_xor(var, assignment.translate(t))
        when '|='
          t.bitwise_or(var, assignment.translate(t))
        when '<<='
          t.bitshift_left(var, assignment.translate(t))
        when '>>='
          t.bitshift_right(var, assignment.translate(t))
        end
        t.assign(var, val)
      end
    }
    /
    equality
  end
  
  rule equality_op
    '==' / '!='
  end
  
  rule equality
    bitwise_and gap? equality_op gap? equality {
      def translate(t, x=nil)
        x ||= bitwise_and.translate(t)
        
        method = case equality_op.text_value
        when '=='
          :equal
        when '!='
          :not_equal
        end
        
        if equality.respond_to? :equality_op
          x = t.send method, x, equality.bitwise_and.translate(t)
          equality.translate t, x
        else
          t.send method, x, equality.translate(t)
        end
      end
    }
    /
    bitwise_and
  end
  
  rule bitwise_and_op
    '&'
  end
  
  rule bitwise_and
    bitwise_xor gap? bitwise_and_op gap? bitwise_and {
      def translate(t, x=nil)
        x ||= bitwise_xor.translate(t)
        
        if bitwise_and.respond_to? :bitwise_and_op
          x = t.bitwise_and(x, bitwise_and.bitwise_xor.translate(t))
          bitwise_and.translate t, x
        else
          t.bitwise_and(x, bitwise_and.translate(t))
        end
      end
    }
    /
    bitwise_xor
  end
  
  rule bitwise_xor_op
    '^'
  end
  
  rule bitwise_xor
    bitwise_or gap? bitwise_xor_op gap? bitwise_xor {
      def translate(t, x=nil)
        x ||= bitwise_or.translate(t)
        
        if bitwise_xor.respond_to? :bitwise_xor_op
          x = t.bitwise_xor(x, bitwise_xor.bitwise_or.translate(t))
          bitwise_xor.translate t, x
        else
          t.bitwise_xor(x, bitwise_xor.translate(t))
        end
      end
    }
    /
    bitwise_or
  end
  
  rule bitwise_or_op
    '|'
  end
  
  rule bitwise_or
    comparison gap? bitwise_or_op gap? bitwise_or {
      def translate(t, x=nil)
        x ||= comparison.translate(t)
        
        if bitwise_or.respond_to? :bitwise_or_op
          x = t.bitwise_or(x, bitwise_or.comparison.translate(t))
          bitwise_or.translate t, x
        else
          t.bitwise_or(x, bitwise_or.translate(t))
        end
      end
    }
    /
    comparison
  end
  
  rule comparison_op
    '>=' / '>' / '<=' / '<'
  end
  
  rule comparison
    bitshift gap? comparison_op gap? comparison {
      def translate(t, x=nil)
        x ||= bitshift.translate(t)
        
        method = case comparison_op.text_value
        when '>'
          :greater
        when '>='
          :greater_or_equal
        when '<'
          :less
        when '<='
          :less_or_equal
        end
        
        if comparison.respond_to? :comparison_op
          x = t.send method, x, comparison.bitshift.translate(t)
          comparison.translate t, x
        else
          t.send method, x, comparison.translate(t)
        end
      end
    }
    /
    bitshift
  end
  
  rule bitshift_op
    '<<' / '>>'
  end
  
  rule bitshift
    sum gap? bitshift_op gap? bitshift {
      def translate(t, x = nil)
        x ||= sum.translate(t)
        
        method = case bitshift_op.text_value
        when '<<'
          :bitshift_left
        when '>>'
          :bitshift_right
        end
        
        if bitshift.respond_to? :bitshift_op
          x = t.send method, x, bitshift.sum.translate(t)
          bitshift.translate t, x
        else
          t.send method, x, bitshift.translate(t)
        end
      end
    }
    /
    sum
  end
  
  rule sum_op
    '+' / '-'
  end
  
  rule sum
    product gap? sum_op gap? sum {
      def translate(t, x = nil)
        x ||= product.translate(t)
        
        method = case sum_op.text_value
        when '+'
          :add
        when '-'
          :subtract
        end
        
        if sum.respond_to? :sum_op
          x = t.send method, x, sum.product.translate(t)
          sum.translate t, x
        else
          t.send method, x, sum.translate(t)
        end
      end
    }
    /
    product
  end
  
  rule product_op
    '*' / '/' / '%'
  end
  
  rule product
    unary gap? product_op gap? product {
      def translate(t, x = nil)
        x ||= unary.translate(t)
        
        method = case product_op.text_value
        when '*'
          :multiply
        when '/'
          :divide
        when '%'
          :modulus
        end
        
        if product.respond_to? :product_op
          x = t.send method, x, product.unary.translate(t)
          product.translate t, x
        else
          t.send method, x, product.translate(t)
        end
      end
    }
    /
    unary
  end
  
  rule unary_op
    '~' / '-' / '@'
  end
  
  rule unary
    unary_op gap? unary {
      def translate(t)
        method = case unary_op.text_value
        when '~'
          :bitwise_not
        when '-'
          :negate
        when '@'
          :address_of
        end
        
        t.send method, unary.translate(t)
      end
    }
    /
    primary
  end

  rule primary
    function_call 
    /
    '(' gap? expression gap? ')' {
      def translate(t)
        expression.translate(t)
      end
    }
    /
    constant
    /
    variable
    /
    '*' unary ':' type {
      def translate(t)
        t.dereference(unary.translate(t), type.translate(t))
      end
    }
    /
    '*' unary {
      def translate(t)
        t.dereference(unary.translate(t))
      end
    }
  end
  
  rule function_name
    [a-zA-Z_] [0-9a-zA-Z_]* {
      def translate(t)
        text_value
      end
    }
  end
  
  rule variable
    [a-zA-Z_] [0-9a-zA-Z_]* {
      def translate(t)
        t.variable(text_value)
      end
    }
  end
  
  rule constant
    null_constant
    /
    boolean_constant
    /
    integer_constant
  end
  
  rule null_constant
    'null' {
      def translate(t)
        t.null
      end
    }
  end
  
  rule boolean_constant
    'true' {
      def translate(t)
        t.true
      end
    }
    /
    'false' {
      def translate(t)
        t.false
      end
    }
  end
  
  rule integer_constant
    '0' {
      def translate(t)
        t.integer_constant(0)
      end
    }
    /
    [1-9] [0-9]* {
      def translate(t)
        t.integer_constant(text_value.to_i)
      end
    }
  end
  
  rule type
    '@'* type_name {
      def translate(t)
        pointer_depth = text_value[0...-type_name.text_value.size].size
        array = []
        pointer_depth.times { array << 'pointer' }
        array << type_name.text_value
        t.type *array
      end
    }
  end
  
  rule type_name
    'uint64' / 'int64' / 'uint32' / 'int32' / 'uint16' / 'int16' / 'uint8' / 'int8'
  end
  
  # Rule matches one or more tabs and/or spaces
  rule gap
    [ \t]+
  end
  
  # Rule matches one or more whitespace characters
  rule ws
    [\s]+
  end
end

